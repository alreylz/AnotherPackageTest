#!/bin/bash
# ----------------------------
# setup.sh (by @alreylz)
# ----------------------------


# 1) Renombra los archivos y contenidos de archivo dados en la plantilla para comenzar un desarrollo
#     - El usuario proporciona : <autor del paquete> , <nombre del nuevo paquete>,
#     -> Adapta la plantilla para un paquete que se llamar치 "com.<autor>.<nombre_paquete>"

#     Los archivos clave a modificar: Assembly definitions:
#     -------------------------------------------------------------------
#     - ./Editor/[AuthorOrCom.TemplatePackage].Editor (asmdef)
#     - ./Runtime/[AuthorOrCom.TemplatePackage].Runtime (asmdef)
#     - ./Tests/Editor/[AuthorOrCom.TemplatePackage].Editor.Tests (asmdef)
#     - ./Tests/Runtime/[AuthorOrCom.TemplatePackage].Tests (asmdef)

# -----------------
# 2) Actualiza package.json
# -----------------

# -----------------
# 3) Inicializa un repositorio compatible con git lfs
# -----------------

echo "################################################################################################
#######  unity-package-template (setup.sh)  ####################################################
################################################################################################
This script does all the repetitive stuff regarding the setup of a unity package for development.
It does so by modifying the a pre-made template package skeleton to match your description.
You will be asked all the questions, just need to answer them :D
                                                                                        @alreylz"
printf "################################################################################################\n\n"

# Set the base directory to start the configuration (by default this script will be placed at the root of the package)
directory="./"

printf "########################\n"
printf "[STEP 1] RENAMING STUFF\n"
printf "########################\n"


read -p "Enter the author or company alias for the package you are initializing: " author
read -p "Enter the name of the package you are initializing: " packageName
read -p "> Setup for a brand new unity package called 'com.$author.$packageName' will be performed, would you like to continue? (y/n) " choice
if [[ $choice != [yY] ]]; then
  echo "Exiting ..."
  exit;
fi

# Important files to rename/modify

files=(
"./Editor/AuthorOrCom.TemplatePackage.Editor.asmdef"
"./Runtime/AuthorOrCom.TemplatePackage.Runtime.asmdef"
"./Tests/Editor/AuthorOrCom.TemplatePackage.Editor.Tests.asmdef"
"./Tests/Runtime/AuthorOrCom.TemplatePackage.Tests.asmdef"
    # Add more files here as needed
)

npmPackageName="com.$author.$packageName"

search="AuthorOrCom.TemplatePackage"
replacement="$author.$packageName"

# Search inside files and replace matches of template strings
for file in "${files[@]}"; do
    file_path="$file"
    echo "[...]Replacing $search in $file_path"
    sed -i "s/$search/$replacement/g" "$file_path"
done


# Rename files to match new structure
toRenameFiles=$(find "$directory" -type f -name "*$search*")
echo "The following files will be renamed to fit the new package:"
echo "$toRenameFiles"
read -p "Would you like to continue? (y/n) " choice
if [[ $choice != [yY] ]]; then
  echo "Exiting ..."
  exit;
fi

# Find all files in the directory (including subdirectories) matching the search pattern
for file in $toRenameFiles; do
    # Extract the file's directory and name
    file_dir=$(dirname "$file")
    file_name=$(basename "$file")
    # Perform the search and replace operation on the file name
    new_name="${file_name/$search/$replacement}"
    # Construct the new file path
    new_path="$file_dir/$new_name"
    echo "[...] renaming $file -> $new_path"
    # Rename the file
    mv "$file" "$new_path"
done

echo "> Enter the display name for the package: "
read -r displayName
echo "> Enter a description for the package: "
read -r  description

# Commit changes to package.json
json_file="${directory}package.json"


echo "[...] Modifying $json_file ...."

# Cambiar nombre del paquete de npm y la versi칩n
jq --arg new_value "$npmPackageName" '.name= $new_value' "$json_file" > temp.json && mv temp.json "$json_file"
jq --arg new_value "0.0.1" '.version= $new_value' "$json_file" > temp.json && mv temp.json "$json_file"

# Cambiar otros datos
nuDName=$displayName
jq --arg new_value "$nuDName" '.displayName= $new_value' "$json_file" > temp.json && mv temp.json "$json_file"
nuDesc=$description
jq --arg new_value "$nuDesc" '.description= $new_value' "$json_file" > temp.json && mv temp.json "$json_file"

printf "[...] Updating README.md"
# Escribir en el README.md
newReadmeContent="#Readme for $npmPackageName\n this document was autogenerated using @alreylz's **setup.sh**"
echo "$newReadmeContent" > README.md



printf "###############################\n"
printf "[STEP 3] INITIALIZING GIT REPO \n"
printf "###############################\n"

echo "Realizando configuraciones git"
# inicializar repositorio git
git init
# A침adir un .gitignore para este archivo
echo "setup.sh" >> .gitignore
# A침adir git lfs
git lfs install

read -p "Enter the link for your remote repo - make sure it ends with .git -  (an alias of 'origin') will be configured for it " remoteRepo
git remote add origin "$remoteRepo"

# Volver a permitir tracking de archivos .meta a partir de ahora (pues esto ya no es un template y unity necesita los meta)
echo "Re-enabling .meta tracking in .gitignore"
sed -i "s/*.meta/#*.meta/g" ".gitignore"

